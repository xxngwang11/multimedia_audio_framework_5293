diff --git a/test/BUILD.gn b/test/BUILD.gn
index 25e33c95e5fc7342fd5c84cd98ab1c16ef318b0c..1d009ba404f5679ee702a73f892a892a43510445 100644
--- a/test/BUILD.gn
+++ b/test/BUILD.gn
@@ -222,6 +222,13 @@ group("audio_fuzz_test") {
     # "fuzztest/audiopolicymore_fuzzer:fuzztest",
     "fuzztest/audiopolicyproxy_fuzzer:fuzztest",
 
+    "fuzztest/audiohpaeengine_fuzzer:fuzztest",
+    "fuzztest/audiohpaepcmbuffer_fuzzer:fuzztest",
+    "fuzztest/audiohpaepcmprocess_fuzzer:fuzztest",
+    "fuzztest/audiohpaecapturermanager_fuzzer:fuzztest",
+    "fuzztest/audiohpaeinnercapturermanager_fuzzer:fuzztest",
+    #"fuzztest/audiohpaemanagerimpl_fuzzer:fuzztest",
+
     # "fuzztest/audiopolicyservenhance_fuzzer:fuzztest",
     "fuzztest/audiopolicyserverhandler_fuzzer:fuzztest",
 
diff --git a/test/fuzztest/audiohpaecapturermanager_fuzzer/BUILD.gn b/test/fuzztest/audiohpaecapturermanager_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..3ef255d377df733ac418fa602699214ccb546e50
--- /dev/null
+++ b/test/fuzztest/audiohpaecapturermanager_fuzzer/BUILD.gn
@@ -0,0 +1,105 @@
+# Copyright (c) 2024 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("AudioHpaeCapturerManagerFuzzTest") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../audiohpaecapturermanager_fuzzer"
+
+  include_dirs = [
+    "../../../frameworks/native/audioschedule/include",
+    "../../../frameworks/native/hdiadapter_new/include/manager",
+    "../../../interfaces/inner_api/native/audiocommon/include",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_engine/manager/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_policy/server/include/service",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/simd",
+    "../../../services/audio_engine/dfx",
+  ]
+
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "audiohpaecapturermanager_fuzzer.cpp" ,
+    ]
+
+  deps = [
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../../services/audio_policy:audio_policy_service",
+    "../../../services/audio_service:audio_common",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "relational_store:native_appdatafwk",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":AudioHpaeCapturerManagerFuzzTest" ]
+}
\ No newline at end of file
diff --git a/test/fuzztest/audiohpaecapturermanager_fuzzer/audiohpaecapturermanager_fuzzer.cpp b/test/fuzztest/audiohpaecapturermanager_fuzzer/audiohpaecapturermanager_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..06d67fedb65d40ca96cfa6cbd728d7788e6255cb
--- /dev/null
+++ b/test/fuzztest/audiohpaecapturermanager_fuzzer/audiohpaecapturermanager_fuzzer.cpp
@@ -0,0 +1,389 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "audio_info.h"
+#include "i_stream.h"
+#include "hpae_capturer_manager.h"
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+std::shared_ptr<HpaeCapturerManager> HpaeCapturerManager_ = nullptr
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+const uint8_t TESTSIZE = 32;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t)
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+void CreateStreamFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeStreamInfo streamInfo;
+    HpaeCapturerManager_->CreateStream(streamInfo);
+}
+
+void DestroyStreamFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    HpaeCapturerManager_->DestroyStream(sessionId);
+}
+
+void StartFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    HpaeCapturerManager_->Start(sessionId);
+}
+
+void PauseFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    HpaeCapturerManager_->Pause(sessionId);
+}
+
+void FlushFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    HpaeCapturerManager_->Flush(sessionId);
+}
+
+void DrainFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    HpaeCapturerManager_->Drain(sessionId);
+}
+
+void StopFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    HpaeCapturerManager_->Stop(sessionId);
+}
+
+void ReleaseFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    HpaeCapturerManager_->Release(sessionId);
+}
+
+void MoveStreamFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    const std::string &sourceName = sourceInfo.sourceName;
+    HpaeCapturerManager_->MoveStream(sessionId,sourceName);
+}
+
+void MoveAllStreamFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    const std::vector<uint32_t> &sessionIds = {1,2,3};
+    const std::string &sourceName = sourceInfo.sourceName;
+    HpaeCapturerManager_->MoveAllStream(sourceName,sessionIds);
+}
+
+void SetMuteFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    bool isMute = false;
+    HpaeCapturerManager_->SetMute(isMute);
+}
+
+void ProcessFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->Process();
+}
+
+void HandleMsgFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->HandleMsg();
+}
+
+void InitFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->Init();
+}
+
+void DeInitFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->DeInit();
+}
+
+void IsInitFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->IsInit();
+}
+
+void IsRunningFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->IsRunning();
+}
+
+void IsMsgProcessingFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->IsMsgProcessing();
+}
+
+void DeactivateThreadFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->DeactivateThread();
+}
+
+void RegisterReadCallbackFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    const std::weak_ptr<ICapturerStreamCallback> &callback = std::weak_ptr<ICapturerStreamCallback>();
+    HpaeCapturerManager_->RegisterReadCallback(sessionId,callback);
+}
+
+void GetSourceOutputInfoFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    HpaeSourceOutputInfo sourceOutputInfo;
+    HpaeCapturerManager_->GetSourceOutputInfo(sessionId,sourceOutputInfo);
+}
+
+void GetSourceInfoFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->GetSourceInfo();
+}
+
+void GetAllSourceInfoFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->GetAllSourceInfo();
+}
+
+void OnNodeStatusUpdateFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    IOperation operation = IOperation::OPERATION_INVALID;
+    HpaeCapturerManager_->OnNodeStatusUpdate(sessionId,operation);
+}
+
+void OnNotifyQueueFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->OnNotifyQueue();
+}
+
+void OnRequestLatencyFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t sessionId = 0;
+    uint64_t latency = 0;
+    HpaeCapturerManager_->OnRequestLatency(sessionId,latency);
+}
+
+void AddNodeToSourceFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCaptureMoveInfo moveInfo;
+    HpaeCapturerManager_->AddNodeToSource(moveInfo);
+}
+
+void AddAllNodesToSourceFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    std::vector<HpaeCaptureMoveInfo> moveInfoVector;
+    std::vector<HpaeCaptureMoveInfo> &moveInfos = moveInfoVector;
+    bool isConnect = false;
+    HpaeCapturerManager_->AddAllNodesToSource(moveInfos,isConnect);
+}
+
+void GetTheadNameFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->GetTheadName();
+}
+
+void SetCaptureIdFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    uint32_t captureId = 3;
+    HpaeCapturerManager_->SetCaptureId(captureId);
+}
+
+void ReloadCaptureManagerFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->ReloadCaptureManager(sourceInfo);
+}
+
+void GetDeviceHDFDumpInfoFuzzTest()
+{
+    HpaeSourceInfo sourceInfo;
+    HpaeCapturerManager_ = std::make_shared<HpaeCapturerManager>(sourceInfo);
+    HpaeCapturerManager_->GetDeviceHDFDumpInfo();
+}
+
+typedef void (*TestFuncs[32])();
+
+TestFuncs g_testFuncs = {
+    CreateStreamFuzzTest,
+    DestroyStreamFuzzTest,
+    StartFuzzTest,
+    PauseFuzzTest,
+    FlushFuzzTest,
+    DrainFuzzTest,
+    StopFuzzTest,
+    ReleaseFuzzTest,
+    MoveStreamFuzzTest,
+    MoveAllStreamFuzzTest,
+    SetMuteFuzzTest,
+    ProcessFuzzTest,
+    HandleMsgFuzzTest,
+    InitFuzzTest,
+    DeInitFuzzTest,
+    IsInitFuzzTest,
+    IsRunningFuzzTest,
+    IsMsgProcessingFuzzTest,
+    DeactivateThreadFuzzTest,
+    RegisterReadCallbackFuzzTest,
+    GetSourceOutputInfoFuzzTest,
+    GetSourceInfoFuzzTest,
+    GetAllSourceInfoFuzzTest,
+    OnNodeStatusUpdateFuzzTest,
+    OnNotifyQueueFuzzTest,
+    OnRequestLatencyFuzzTest,
+    AddNodeToSourceFuzzTest,
+    AddAllNodesToSourceFuzzTest,
+    GetTheadNameFuzzTest,
+    ReloadCaptureManagerFuzzTest,
+    GetDeviceHDFDumpInfoFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
\ No newline at end of file
diff --git a/test/fuzztest/audiohpaecapturermanager_fuzzer/project.xml b/test/fuzztest/audiohpaecapturermanager_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/audiohpaecapturermanager_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/audiohpaeengine_fuzzer/BUILD.gn b/test/fuzztest/audiohpaeengine_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..4ddb8f2d583133009694af100b1ac542269f61fc
--- /dev/null
+++ b/test/fuzztest/audiohpaeengine_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2024 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("AudioHpaeEngineFuzzTest") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../audiohpaeengine_fuzzer"
+
+  include_dirs = [
+    "../../../frameworks/native/audioadapter/include",
+    "../../../frameworks/native/hdiadapter_new/include/manager",
+    "../../../frameworks/native/hdiadapter_new/include/util",
+    "../../../interfaces/inner_api/native/audiocommon/include",
+    "../../../services/audio_engine/manager/include",
+    "../../../services/audio_policy/server/include/service",
+    "../../../services/audio_policy/server/include",
+    "../../../services/audio_service/server/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "audiohpaepcmprocess_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../frameworks/native/hdiadapter_new:hdiadapter_new",
+    "../../../frameworks/native/audioadapter:pulse_audio_service_adapter",
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../../services/audio_policy:audio_policy_service",
+    "../../../services/audio_service:audio_common",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":AudioHpaeEngineFuzzTest" ]
+}
\ No newline at end of file
diff --git a/test/fuzztest/audiohpaeengine_fuzzer/audiohpaeengine_fuzzer.cpp b/test/fuzztest/audiohpaeengine_fuzzer/audiohpaeengine_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..f65082d87fdf4e02939d884f4cebe0e2780f65de
--- /dev/null
+++ b/test/fuzztest/audiohpaeengine_fuzzer/audiohpaeengine_fuzzer.cpp
@@ -0,0 +1,449 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <sstream>
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include "audio_info.h"
+#include "id_handler.h"
+#include "hdi_adapter_manager.h"
+#include "pro_audio_service_adapter_impl.h"
+#include "audio_device_info.h"
+#include "i_hpae_manager.h"
+#include "audio_effect.h"
+#include "audio_log.h"
+
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+namespace OHOS {
+namespace AudioStandard {
+std::shared_ptr<ProAudioServiceAdapterImpl> impl_ = nullptr;
+static std::string g_rootPath = "/data/";
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t)
+std::mutex lock_;
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+class AudioServiceAdapterCallbackTest : public AudioServiceAdapterCallback {
+public:
+    void OnAudioStreamRemoved(const uint64_t sessionID) override
+    {
+        return;
+    }
+    void OnSetVolumeDbCb() override
+    {
+        return;
+    }
+};
+
+static AudioModuleInfo InitSinkAudioModeInfo()
+{
+    AudioModuleInfo audioModuleInfo;
+    audioModuleInfo.lib = "libmodule-hdi-sink.z.so";
+    audioModuleInfo.channels = "2";
+    audioModuleInfo.rate = "48000";
+    audioModuleInfo.name = "Speaker_File";
+    audioModuleInfo.adapterName = "file_io";
+    audioModuleInfo.className = "file_io";
+    audioModuleInfo.bufferSize = "7680";
+    audioModuleInfo.format = "s32le";
+    audioModuleInfo.fixedLatency = "1";
+    audioModuleInfo.offloadEnable = "0";
+    audioModuleInfo.networkId = "LocalDevice";
+    audioModuleInfo.fileName = g_rootPath + audioModuleInfo.adapterName + "_" + audioModuleInfo.rate + "_" + audioModuleInfo.channels
+    + "_" + audioModuleInfo.format + ".pcm";
+    std::stringstream typeValue;
+    typeValue << static_cast<int32_t>(DEVICE_TYPE_SPEAKER);
+    audioModuleInfo.deviceType = typeValue.str();
+    return audioModuleInfo;
+}
+
+static AudioModuleInfo InitSourceAudioModeInfo()
+{
+    AudioModuleInfo audioModuleInfo;
+    audioModuleInfo.lib = "libmodule-hdi-Source.z.so";
+    audioModuleInfo.channels = "2";
+    audioModuleInfo.rate = "48000";
+    audioModuleInfo.name = "mic";
+    audioModuleInfo.adapterName = "file_io";
+    audioModuleInfo.className = "file_io";
+    audioModuleInfo.bufferSize = "3840";
+    audioModuleInfo.format = "s16le";
+    audioModuleInfo.fixedLatency = "1";
+    audioModuleInfo.offloadEnable = "0";
+    audioModuleInfo.networkId = "LocalDevice";
+    audioModuleInfo.fileName = g_rootPath + audioModuleInfo.adapterName + "_" + audioModuleInfo.rate + "_" + audioModuleInfo.channels
+    + "_" + audioModuleInfo.format + ".pcm";
+    std::stringstream typeValue;
+    typeValue << static_cast<int32_t>(DEVICE_TYPE_SPEAKER);
+    audioModuleInfo.deviceType = typeValue.str();
+    return audioModuleInfo;
+}
+
+void SetUp()
+{
+    lock_guard<mutex> lock(lock_);
+    if (impl_ != nullptr) {
+        return;
+    }
+    IdHandler::GetInstance();
+    HdiAdapterManager::GetInstance();
+    std::unique_ptr<AudioServiceAdapterCallbackTest> cb = std::make_unique<AudioServiceAdapterCallbackTest>();
+    impl_ = std::static_pointer_cast<ProAudioServiceAdapterImpl>(
+        OHOS::AudioStandard::AudioServiceAdapter::CreateAudioAdapter(std::move(cb),true));
+    impl_->Connect();
+    HPAE::IHpaeManager::GetHpaeManager().Init();
+}
+
+void OpenAudioPortFuzzTest()
+{
+    SetUp();
+    AudioModuleInfo moduleInfo = InitSinkAudioModeInfo();
+    impl_->OpenAudioPort(moduleInfo.lib,moduleInfo);
+}
+
+void CloseAudioPortFuzzTest()
+{
+    SetUp();
+    AudioModuleInfo moduleInfo = InitSinkAudioModeInfo();
+    int32_t portId = impl_->OpenAudioPort(moduleInfo.lib,moduleInfo);
+    impl_->CloseAudioPort(portId);
+}
+
+void SetDefaultSinkFuzzTest()
+{
+    SetUp();
+    AudioModuleInfo moduleInfo = InitSinkAudioModeInfo();
+    impl_->SetDefaultSink(moduleInfo.name);
+}
+
+void SetDefaultSourceFuzzTest()
+{
+    SetUp();
+    AudioModuleInfo moduleInfo = InitSinkAudioModeInfo();
+    impl_->SetDefaultSource(moduleInfo.name);
+}
+
+void SetSourceOutputMuteFuzzTest()
+{
+    SetUp();
+    AudioModuleInfo moduleInfo = InitSinkAudioModeInfo();
+    int32_t portId = impl_->OpenAudioPort(moduleInfo,lib,moduleInfo);
+    impl_->SetSourceOutputMute(portId,true);
+}
+
+void SuspendAudioDeviceFuzzTest()
+{
+    SetUp();
+    AudioModuleInfo moduleInfo = InitSinkAudioModeInfo();
+    impl_->SuspendAudioDevice(moduleInfo.name,true);
+}
+
+void SetSinkMuteFuzzTest()
+{
+    SetUp();
+    AudioModuleInfo moduleInfo = InitSinkAudioModeInfo();
+    impl_->SetSinkMute(moduleInfo.name,true);
+}
+
+void GetAllSinkInputsFuzzTest()
+{
+    SetUp();
+    impl_->GetAllSinkInputs();
+}
+
+void GetAllSourceOutputsFuzzTest()
+{
+    SetUp();
+    impl_->GetAllSourceOutputs();
+}
+
+void DisconnectFuzzTest()
+{
+    SetUp();
+    impl_->DisconnectFuzzTest();
+}
+
+void GetTargetSinksFuzzTest()
+{
+    SetUp();
+    std::string adapterName = "adapterNameFuzzTest";
+    impl_->GetTargetSinks(adapterName);
+}
+
+void GetAllSinksFuzzTest()
+{
+    SetUp();
+    std::string adapterName = "adapterNameFuzzTest";
+    impl_->GetAllSinks(adapterName);
+}
+
+void SetLocalDefaultSinkFuzzTest()
+{
+    SetUp();
+    std::string name = "SinkName";
+    impl_->SetLocalDefaultSink(name);
+}
+
+void MoveSinkInputByIndexOrNameFuzzTest()
+{
+    SetUp();
+    uint32_t sinkInputId = 100;
+    uint32_t sinkIndex = 0;
+    std::string sinkName = "SinkInputName";
+    impl_->MoveSinkInputByIndexOrName(sinkInputId,sinkIndex,sinkName);
+}
+
+void MoveSourceOutputByIndexOrNameFuzzTest()
+{
+    SetUp();
+    uint32_t sinkInputId = 1111;
+    uint32_t sinkIndex = 0;
+    std::string sinkName = "SourceOutputName";
+    impl_->MoveSourceOutputByIndexOrName(sinkInputId,sinkIndex,sinkName);
+}
+
+void GetAudioEffectPropertyV3FuzzTest()
+{
+    SetUp();
+    AudioEffectPropertyArrayV3 propertyArray;
+    impl_->GetAudioEffectPropertyV3(propertyArray);
+}
+
+void GetAudioEffectPropertyFuzzTest()
+{
+    SetUp();
+    AudioEffectPropertyArray propertyArray;
+    impl_->GetAudioEffectProperty(propertyArray);
+}
+
+void GetAudioEnhancePropertyV3FuzzTest()
+{
+    SetUp();
+    AudioEffectPropertyArrayV3 propertyArray;
+    impl_->GetAudioEnhancePropertyV3(propertyArray);
+}
+
+void GetAudioEnhancePropertyFuzzTest()
+{
+    SetUp();
+    AudioEnhancePropertyArray propertyArray;
+    impl_->GetAudioEnhanceProperty(propertyArray);
+}
+
+void OnOpenAudioPortCbFuzzTest()
+{
+    SetUp();
+    AudioModuleInfo moduleInfo =  InitSinkAudioModeInfo();
+    int32_t portId = impl_->OpenAudioPort(moduleInfo.lib,moduleInfo);
+    impl_->OnOpenAudioPortCb(portId);
+}
+
+void OnCloseAudioPortCbFuzzTest()
+{
+    SetUp();
+    int32_t result = GetData<int32_t>();
+    impl_->OnCloseAudioPortCb(result);
+}
+
+void OnSetSinkMuteCbFuzzTest()
+{
+    SetUp();
+    int32_t result = GetData<int32_t>();
+    impl_->OnSetSinkMuteCb(result);
+}
+
+void OnSetSourceOutputMuteCbFuzzTest()
+{
+    SetUp();
+    int32_t result = GetData<int32_t>();
+    impl_->OnSetSourceOutputMuteCb(result);
+}
+
+void OnGetAllSinkInputsCbFuzzTest()
+{
+    SetUp();
+    std::vector<SinkInput> sinkInputs = impl_->GetAllSinkInputs();
+    int32_t result = GetData<int32_t>();
+    impl_->OnGetAllSinkInputsCb(result,sinkInputs);
+}
+
+void OnGetAllSourceOutputsCbFuzzTest()
+{
+    SetUp();
+    std::vector<SourceOutput> sourceOutputs = impl_->GetAllSourceOutputs();
+    int32_t result = GetData<int32_t>();
+    impl_->OnGetAllSourceOutputsCb(result,sourceOutputs);
+}
+
+void OnGetAllSinksCbFuzzTest()
+{
+    SetUp();
+    std::vector<SinkInfo> sinks();
+    int32_t result = GetData<int32_t>();
+    impl_->OnGetAllSinkCb(result,sinks);
+}
+
+void OnMoveSinkInputByIndexOrNameCbFuzzTest()
+{
+    SetUp();
+    int32_t result = GetData<int32_t>();
+    impl_->OnMoveSinkInputByIndexOrNameCb(result);
+}
+
+void OnMoveSourceOutputByIndexOrNameCbFuzzTest()
+{
+    SetUp();
+    int32_t result = GetData<int32_t>();
+    impl_->OnMoveSourceOutputByIndexOrNameCb(result);
+}
+
+void OnGetAudioEffectPropertyCbV3FuzzTest()
+{
+    SetUp();
+    int32_t result = GetData<int32_t>();
+    impl_->OnGetAudioEffectPropertyCbV3(result);
+}
+
+void OnGetAudioEffectPropertyCbFuzzTest()
+{
+    SetUp();
+    int32_t result = GetData<int32_t>();
+    impl_->OnGetAudioEffectPropertyCb(result);
+}
+
+void OnGetAudioEnhancePropertyCbV3FuzzTest()
+{
+    SetUp();
+    int32_t result = GetData<int32_t>();
+    impl_->OnGetAudioEnhancePropertyCbV3(result);
+}
+
+void OnGetAudioEnhancePropertyCbFuzzTest()
+{
+    SetUp();
+    int32_t result = GetData<int32_t>();
+    impl_->OnGetAudioEnhancePropertyCb(result);
+}
+
+void HandleSourceAudioStreamRemovedFuzzTest()
+{
+    SetUp();
+    uint32_t sessionId = GetData<int32_t>();
+    impl_->HandleSourceAudioStreamRemoved(sessionId);
+}
+
+typedef void (*TestFuncs[33])();
+
+TestFuncs g_testFuncs = {
+    OpenAudioPortFuzzTest,
+    CloseAudioPortFuzzTest,
+    SetDefaultSinkFuzzTest,
+    SetDefaultSourceFuzzTest,
+    SetSourceOutputMuteFuzzTest,
+    SuspendAudioDeviceFuzzTest,
+    SetSinkMuteFuzzTest,
+    GetAllSinkInputsFuzzTest,
+    GetAllSourceOutputsFuzzTest,
+    DisconnectFuzzTest,
+    GetTargetSinksFuzzTest,
+    GetAllSinksFuzzTest,
+    SetLocalDefaultSinkFuzzTest,
+    MoveSinkInputByIndexOrNameFuzzTest,
+    MoveSourceOutputByIndexOrNameFuzzTest,
+    GetAudioEffectPropertyV3FuzzTest,
+    GetAudioEffectPropertyFuzzTest,
+    GetAudioEnhancePropertyV3FuzzTest,
+    GetAudioEnhancePropertyFuzzTest,
+    OnOpenAudioPortCbFuzzTest,
+    OnCloseAudioPortCbFuzzTest,
+    OnSetSinkMuteCbFuzzTest,
+    OnSetSourceOutputMuteCbFuzzTest,
+    OnGetAllSinkInputsCbFuzzTest,
+    OnGetAllSourceOutputsCbFuzzTest,
+    OnGetAllSinksCbFuzzTest,
+    OnMoveSinkInputByIndexOrNameCbFuzzTest,
+    OnMoveSourceOutputByIndexOrNameCbFuzzTest,
+    OnGetAudioEffectPropertyCbV3FuzzTest,
+    OnGetAudioEffectPropertyCbFuzzTest,
+    OnGetAudioEnhancePropertyCbV3FuzzTest,
+    OnGetAudioEnhancePropertyCbFuzzTest,
+    HandleSourceAudioStreamRemovedFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
\ No newline at end of file
diff --git a/test/fuzztest/audiohpaeengine_fuzzer/project.xml b/test/fuzztest/audiohpaeengine_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/audiohpaeengine_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/audiohpaeinnercapturermanager_fuzzer/BUILD.gn b/test/fuzztest/audiohpaeinnercapturermanager_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..f6642f13233b1bb3bccfefda5006987f40a48274
--- /dev/null
+++ b/test/fuzztest/audiohpaeinnercapturermanager_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2024 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("AudioHpaeEngineFuzzTest") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../audiohpaeinnercapturermanager_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "audiohpaeinnercapturermanager_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../..services/audio_service:audio_service,
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":AudioHpaeInnerCapturerManagerFuzzTest" ]
+}
\ No newline at end of file
diff --git a/test/fuzztest/audiohpaeinnercapturermanager_fuzzer/audiohpaeinnercapturermanager_fuzzer.cpp b/test/fuzztest/audiohpaeinnercapturermanager_fuzzer/audiohpaeinnercapturermanager_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..adfda41d28073cbbc15ddd24dbaeeccd8c79182b
--- /dev/null
+++ b/test/fuzztest/audiohpaeinnercapturermanager_fuzzer/audiohpaeinnercapturermanager_fuzzer.cpp
@@ -0,0 +1,500 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "audio_info.h"
+#include "hpae_inner_capturer_manager.h"
+#include "i_hpae_renderer_manager.h"
+
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t)
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    const HpaeStreamInfo streamInfo = {};
+    hpaeInnerCapturerManager->DoProcess(streamInfo);
+}
+
+void DestroyStreamFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    hpaeInnerCapturerManager->DestroyStream(sessionId);
+}
+
+void StartFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    hpaeInnerCapturerManager->Start(sessionId);
+}
+
+void PauseFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    hpaeInnerCapturerManager->Pause(sessionId);
+}
+
+void FlushFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    hpaeInnerCapturerManager->Flush(sessionId);
+}
+
+void DrainFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    hpaeInnerCapturerManager->Drain(sessionId);
+}
+
+void StopFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    hpaeInnerCapturerManager->Stop(sessionId);
+}
+
+void ReleaseFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    hpaeInnerCapturerManager->Release(sessionId);
+}
+
+void MoveStreamFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    const std::string &sinkName = "13222";
+    hpaeInnerCapturerManager->MoveStream(sessionId,sinkName);
+}
+
+void MoveAllStreamFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    const std::vector<uint32_t> &sessionId = {GetData<uint32_t>(),GetData<uint32_t>(),GetData<uint32_t>()};
+    const std::string &sinkName = "13222";
+    hpaeInnerCapturerManager->MoveAllStream(sinkName,sessionId);
+}
+
+void SuspendStreamManagerFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    bool isSuspend = GetData<bool>();
+    hpaeInnerCapturerManager->SuspendStreamManager(isSuspend);
+}
+
+void SetMuteFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    bool isMute = GetData<bool>();
+    hpaeInnerCapturerManager->SetMute(isMute);
+}
+
+void ProcessFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->Process();
+}
+
+void HandleMsgFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->HandleMsg();
+}
+
+void InitFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->Init();
+}
+
+void DeInitFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->DeInit();
+}
+
+void IsInitFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->IsInit();
+}
+
+void IsRunningFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->IsRunning();
+}
+
+void IsMsgProcessingFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->IsMsgProcessing();
+}
+
+void DeactivateThreadFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->DeactivateThread();
+}
+
+void SetClientVolumeFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    float volume = GetData<float>();
+    hpaeInnerCapturerManager->SetClientVolume(sessionId,volume);
+}
+
+void SetRateFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    int32_t rate = GetData<int32_t>();
+    hpaeInnerCapturerManager->SetRate(sessionId,rate);
+}
+
+void SetAudioEffectModeFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    int32_t effectMode = GetData<int32_t>();
+    hpaeInnerCapturerManager->SetAudioEffectMode(sessionId,effectMode);
+}
+
+void GetAudioEffectModeFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    int32_t e = GetData<int32_t>();
+    int32_t &effectMode = e;
+    hpaeInnerCapturerManager->GetAudioEffectMode(sessionId,effectMode);
+}
+
+void SetPrivacyTypeFuzzTest()
+
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    int32_t privacyType = GetData<int32_t>();
+    hpaeInnerCapturerManager->SetPrivacyType(sessionId,privacyType);
+}
+
+void GetPrivacyTypeFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    int32_t p = GetData<int32_t>();
+    int32_t &privacyType = p;
+    hpaeInnerCapturerManager->GetprivacyType(sessionId,privacyType);
+}
+
+void RegisterWriteCallbackFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    const std::weak_ptr<IStreamCallback> &callback = std::weak_ptr<IStreamCallback>();
+    hpaeInnerCapturerManager->RegisterWriteCallback(sessionId,callback);
+}
+
+void GetWritableSizeFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    hpaeInnerCapturerManager->GetWritableSize(sessionId);
+}
+
+void UpdateSpatializationStateFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    hpaeInnerCapturerManager->UpdateSpatializationState(sessionId,true,true);
+}
+
+void UpdateMaxLengthFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    uint32_t maxLength = GetData<uint32_t>();
+    hpaeInnerCapturerManager->UpdateMaxLength(sessionId,maxLength);
+}
+
+void GetAllSinkInputsInfoFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->GetAllSinkInputsInfo();
+}
+
+void GetSinkInputInfoFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    HpaeSinkInputInfo sinkInputInfo;
+    hpaeInnerCapturerManager->GetSinkInputInfo(sessionId,sinkInputInfo);
+}
+
+void GetSinkInfoFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->GetSinkInfo();
+}
+
+void OnNodeStatusUpdateFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    IOperation operation = IOperation::OPERATION_INVALID;
+    hpaeInnerCapturerManager->OnNodeStatusUpdate(sessionId,operation);
+}
+
+void OnFadeDoneFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    IOperation operation = IOperation::OPERATION_INVALID;
+    hpaeInnerCapturerManager->OnFadeDone(sessionId,operation);
+}
+
+void AddNodeToSinkFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    HpaeNodeInfo nodeInfo;
+    const std::shared_ptr<HpaeSinkInputNode> &node = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeInnerCapturerManager->AddNodeToSink(node);
+}
+
+void AddAllNodesToSinkFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    std::vector<std::shared_ptr<HpaeSinkInputNode>> inputs;
+    const std::vector<std::shared_ptr<HpaeSinkInputNode>> &sinkInputs = inputs;
+    hpaeInnerCapturerManager->AddAllNodesToSink(sinkInputs,true);
+}
+
+void RegisterReadCallbackFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    const std::weak_ptr<ICapturerStreamCallback> &callback = std::weak_ptr<ICapturerStreamCallback>();
+    hpaeInnerCapturerManager->RegisterReadCallback(sessionId,callback);
+}
+
+void GetSourceOutputInfoFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    HpaeSourceOutputInfo sourceOutputInfo;
+    hpaeInnerCapturerManager->GetSourceOutputInfo(sessionId,sourceOutputInfo);
+}
+
+void GetAllSourceOutputsInfoFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->GetAllSourceOutputsInfo();
+}
+
+void GetThreadNameFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->GetThreadName();
+}
+
+void ReloadRenderManagerFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->ReloadRenderManager(sinkInfo);
+}
+
+void GetDeviceHDFDumpInfoFuzzTest()
+{
+    HpaeSinkInfo sinkInfo;
+    auto hpaeInnerCapturerManager = std::make_shared<HpaeInnerCapturerManager>(sinkInfo);
+    hpaeInnerCapturerManager->GetDeviceHDFDumpInfo();
+}
+
+typedef void (*TestFuncs[43])();
+
+TestFuncs g_testFuncs = {
+    CreateStreamFuzzTest,
+    DestroyStreamFuzzTest,
+    StartFuzzTest,
+    PauseFuzzTest,
+    FlushFuzzTest,
+    DrainFuzzTest
+    StopFuzzTest,
+    ReleaseFuzzTest,
+    MoveStreamFuzzTest,
+    MoveAllStreamFuzzTest,
+    SuspendStreamManagerFuzzTest,
+    SetMuteFuzzTest,
+    ProcessFuzzTest,
+    HandleMsgFuzzTest,
+    InitFuzzTest,
+    DeInitFuzzTest,
+    IsInitFuzzTest,
+    IsRunningFuzzT,
+    IsMsgProcessingFuzzTest,
+    DeactivateThreadFuzzTest,
+    SetClientVolumeFuzzTest,
+    SetRateFuzzTest,
+    SetAudioEffectModeFuzzTest
+    GetAudioEffectModeFuzzTest,
+    SetPrivacyTypeFuzzTest,
+    GetPrivacyTypeFuzzTest,
+    RegisterWriteCallbackFuzzTest,
+    GetWritableSizeFuzzTest,
+    UpdateSpatializationStateFuzzTest,
+    UpdateMaxLengthFuzzTest,
+    GetAllSinkInputsInfoFuzzTest,
+    GetSinkInputInfoFuzzTest,
+    GetSinkInfoFuzzTest,
+    OnNodeStatusUpdateFuzzTest,
+    OnFadeDoneFuzzTest,
+    AddNodeToSinkFuzzTest,
+    AddAllNodesToSinkFuzzTest,
+    RegisterReadCallbackFuzzTest,
+    GetSourceOutputInfoFuzzTest,
+    GetAllSourceOutputsInfoFuzzTest,
+    GetThreadNameFuzzTest,
+    ReloadRenderManagerFuzzTest,
+    GetDeviceHDFDumpInfoFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/audiohpaeinnercapturermanager_fuzzer/project.xml b/test/fuzztest/audiohpaeinnercapturermanager_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/audiohpaeinnercapturermanager_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/audiohpaeoffloadsinkoutputnode_fuzzer/BUILD.gn b/test/fuzztest/audiohpaeoffloadsinkoutputnode_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..a83334dff02382607c5c65ad9c0b6ed077051e9e
--- /dev/null
+++ b/test/fuzztest/audiohpaeoffloadsinkoutputnode_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2024 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("AudioHpaeOffloadSinkOutputNodeFuzzTest") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../audiohpaeoffloadsinkoutputnode_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "audiohpaeoffloadsinkoutputnode_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../..services/audio_service:audio_service,
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":AudioHpaeOffloadSinkOutputNodeFuzzTest" ]
+}
diff --git a/test/fuzztest/audiohpaeoffloadsinkoutputnode_fuzzer/audiohpaeoffloadsinkoutputnode_fuzzer.cpp b/test/fuzztest/audiohpaeoffloadsinkoutputnode_fuzzer/audiohpaeoffloadsinkoutputnode_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..ca97b862b23dd6a0345b19b3d8281710b403ea30
--- /dev/null
+++ b/test/fuzztest/audiohpaeoffloadsinkoutputnode_fuzzer/audiohpaeoffloadsinkoutputnode_fuzzer.cpp
@@ -0,0 +1,299 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "hpae_node.h"
+#include "hpae_pcm_buffer.h"
+#include "audio_info.h"
+#include "sink/i_audio_render_sink.h"
+#include "common/hdi_adapter_info.h"
+#include "manager/hdi_adapter_manager.h"
+#include "high_resolution_timer.h"
+
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t)
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->DoProcess();
+}
+
+void ResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->Reset();
+}
+
+void ResetAllFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->ResetAll();
+}
+
+void ConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeOffloadSinkOutputNode->Connect(preNode);
+}
+
+void DisConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeOffloadSinkOutputNode->DisConnect(preNode);
+}
+
+void GetRenderSinkInstanceFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    const std::string &deviceClass = nodeInfo.deviceClass;
+    const std::string &deviceNetworkId = nodeInfo.deviceNetworkId;
+    hpaeOffloadSinkOutputNode->GetRenderSinkInstance(deviceClass,deviceNetworkId);
+}
+
+void RenderSinkInitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    IAudioSinkAttr attr;
+    hpaeOffloadSinkOutputNode->RenderSinkInit(attr);
+}
+
+void RenderSinkDeInitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->RenderSinkDeInit();
+}
+
+void RenderSinkFlushFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->RenderSinkFlush();
+}
+
+void RenderSinkStartFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->RenderSinkStart();
+}
+
+void RenderSinkStopFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->RenderSinkStop();
+}
+
+void GetPreOutNumFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->GetPreOutNum();
+}
+
+void GetSinkStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->GetSinkState();
+}
+
+void SetSinkStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    StreamManagerState sinkState;
+    hpaeOffloadSinkOutputNode->SetSinkState(sinkState);
+}
+
+void GetRenderFrameDataFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->GetRenderFrameData();
+}
+
+void StopStreamFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->StopStream();
+}
+
+void FlushStreamFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->FlushStream();
+}
+
+void SetPolicyStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    int32_t policyState = GetData<int32_t>();
+    hpaeOffloadSinkOutputNode->SetPolicyState(policyState);
+}
+
+void GetLatencyFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    hpaeOffloadSinkOutputNode->GetLatency();
+}
+
+void SetTimeoutStopThdFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    uint32_t timeoutThdMs = GetData<uint32_t>();
+    hpaeOffloadSinkOutputNode->SetTimeoutStopThd(timeoutThdMs);
+}
+
+void SetOffloadRenderCallbackTypeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    int32_t type = GetData<int32_t>();
+    hpaeOffloadSinkOutputNode->SetOffloadRenderCallbackType(type);
+}
+
+void UpdateAppsUidFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOffloadSinkOutputNode = std::make_shared<HpaeOffloadSinkOutputNode>(nodeInfo);
+    const std::vector<int32_t> &appsUid = GetData<int32_t>();
+    hpaeOffloadSinkOutputNode->UpdateAppsUid(appsUid);
+}
+
+typedef void (*TestFuncs[22])();
+
+TestFuncs g_testFuncs = {
+    DoProcessFuzzTest,
+    ResetFuzzTest,
+    ResetAllFuzzTest,
+    ConnectFuzzTest,
+    DisConnectFuzzTest,
+    GetRenderSinkInstanceFuzzTest,
+    RenderSinkInitFuzzTest,
+    RenderSinkDeInitFuzzTest,
+    RenderSinkFlushFuzzTest,
+    RenderSinkStartFuzzTest,
+    RenderSinkStopFuzzTest,
+    GetPreOutNumFuzzTest,
+    GetSinkStateFuzzTest,
+    SetSinkStateFuzzTest,
+    GetRenderFrameDataFuzzTest,
+    StopStreamFuzzTest,
+    FlushStreamFuzzTest,
+    SetPolicyStateFuzzTest,
+    GetLatencyFuzzTest,
+    SetTimeoutStopThdFuzzTest,
+    SetOffloadRenderCallbackTypeFuzzTest,
+    UpdateAppsUidFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/audiohpaeoffloadsinkoutputnode_fuzzer/project.xml b/test/fuzztest/audiohpaeoffloadsinkoutputnode_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/audiohpaeoffloadsinkoutputnode_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/audiohpaepcmbuffer_fuzzer/BUILD.gn b/test/fuzztest/audiohpaepcmbuffer_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..6c1415b8f27ca69a8e8a7954531aaf3e66c4fbff
--- /dev/null
+++ b/test/fuzztest/audiohpaepcmbuffer_fuzzer/BUILD.gn
@@ -0,0 +1,104 @@
+# Copyright (c) 2024 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("AudioHpaePcmBufferFuzzTest") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../audiohpaepcmbuffer_fuzzer"
+
+  include_dirs = [
+    "../../../frameworks/native/audioadapter/include",
+    "../../../frameworks/native/hdiadapter_new/include/manager",
+    "../../../frameworks/native/hdiadapter_new/include/util",
+    "../../../interfaces/inner_api/native/audiocommon/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_engine/manager/include",
+    "../../../services/audio_policy/server/include/service",
+    "../../../services/audio_engine/simd",
+  ]
+
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "audiohpaepcmbuffer_fuzzer.cpp",
+    "../../../frameworks/native/hdiadapter_new/util/id_handler.cpp",
+    "../../../frameworks/native/audioadapter/src/audio_service_adapter.cpp",
+    "../../../services/audio_engine/buffer/hpae_pcm_buffer.cpp",
+    "../../../services/audio_engine/buffer/hpae_pcm_buffer.h",
+    ]
+
+  deps = [
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../../services/audio_policy:audio_policy_service",
+    "../../../services/audio_service:audio_common",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":AudioHpaePcmBufferFuzzTest" ]
+}
\ No newline at end of file
diff --git a/test/fuzztest/audiohpaepcmbuffer_fuzzer/audiohpaepcmbuffer_fuzzer.cpp b/test/fuzztest/audiohpaepcmbuffer_fuzzer/audiohpaepcmbuffer_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..4e872170f96a052cc01b1fe0062698888803bef7
--- /dev/null
+++ b/test/fuzztest/audiohpaepcmbuffer_fuzzer/audiohpaepcmbuffer_fuzzer.cpp
@@ -0,0 +1,365 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "audio_info.h"
+#include "simd_utils.h"
+#include "hpae_pcm_buffer.h"
+#include "audio_log.h"
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t)
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+void GetPcmBufferInfoFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetPcmBufferInfo();
+}
+
+void GetChannelCountFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetChannelCount();
+}
+
+void GetFrameLenFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetFrameLen();
+}
+
+void GetSampleRateFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetSampleRate();
+}
+
+void IsValidFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->IsValid();
+}
+
+void IsSilenceFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->IsSilence();
+}
+
+void GetBufferStateFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetBufferState();
+}
+
+void GetChannelLayoutFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetChannelLayout();
+}
+
+void ReConfigFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->ReConfig(pcmBufferInfo);
+}
+
+void GetFrameDataFuzzTest1()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    HpaePcmBuffer frameData = HpaePcmBuffer(pcmBufferInfo);
+    hpaePcmBuffer->GetFrameData(frameData);
+}
+
+void GetFrameDataFuzzTest2()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    std::vector<float> frameData(1024,0.0f);
+    hpaePcmBuffer->GetFrameData(frameData);
+}
+
+void PushFrameDataFuzzTest1()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    HpaePcmBuffer frameData = HpaePcmBuffer(pcmBufferInfo);
+    hpaePcmBuffer->PushFrameData(frameData);
+}
+
+void PushFrameDataFuzzTest2()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    std::vector<float> frameData(1024,0.0f);
+    hpaePcmBuffer->PushFrameData(frameData);
+}
+
+void StoreFrameDataFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    HpaePcmBuffer frameData = HpaePcmBuffer(pcmBufferInfo);
+    hpaePcmBuffer->StoreFrameData(frameData);
+}
+
+void SizeFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->Size();
+}
+
+void DataSizeFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->DataSize();
+}
+
+void GetFramesFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetFrames();
+}
+
+void GetReadPosFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetReadPos();
+}
+
+void GetWritePosFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetWritePos();
+}
+
+void UpdateReadPosFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    size_t readPos = hpaePcmBuffer -> GetReadPos();
+    hpaePcmBuffer->UpdateReadPos(readPos);
+}
+
+void UpdateWritePosFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    size_t readPos = hpaePcmBuffer -> GetReadPos();
+    hpaePcmBuffer->UpdateWritePos(readPos);
+}
+
+void SetBufferValidFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    bool vaild = GetData<bool>();
+    hpaePcmBuffer->SetBufferValid(vaild);
+}
+
+void SetBufferSilenceFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    bool silence = GetData<bool>();
+    hpaePcmBuffer->SetBufferSilence(silence);
+}
+
+void SetBufferStateFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    uint32_t state = hpaePcmBuffer -> GetBufferState();
+    hpaePcmBuffer->SetBufferState(state);
+}
+
+void GetCurFramesFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetCurFrames();
+}
+
+void GetPcmDataBufferFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetPcmDataBuffer();
+}
+
+void GetFrameSampleFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetFrameSample();
+}
+
+void GetSourceBufferTypeFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetSourceBufferType();
+}
+
+void SetSourceBufferTypeFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    HpaeSourceBufferType type = hpaePcmBuffer->GetSourceBufferType();
+    hpaePcmBuffer->SetSourceBufferType(type);
+}
+
+void GetSplitStreamTypeFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    hpaePcmBuffer->GetSplitStreamType();
+}
+
+void SetSplitStreamTypeFuzzTest()
+{
+    PcmBufferInfo pcmBufferInfo;
+    auto hpaePcmBuffer = std::make_shared<HpaePcmBuffer>(pcmBufferInfo);
+    HpaeSplitStreamType type = hpaePcmBuffer->GetSplitStreamType();
+    hpaePcmBuffer->SetSplitStreamType(type);
+}
+
+typedef void (*TestFuncs[31])();
+
+TestFuncs g_testFuncs = {
+    GetPcmBufferInfoFuzzTest,
+    GetChannelCountFuzzTest,
+    GetFrameLenFuzzTest,
+    GetSampleRateFuzzTest,
+    IsValidFuzzTest,
+    IsSilenceFuzzTest,
+    GetBufferStateFuzzTest,
+    GetChannelLayoutFuzzTest,
+    ReConfigFuzzTest,
+    GetFrameDataFuzzTest1,
+    GetFrameDataFuzzTest2,
+    PushFrameDataFuzzTest1,
+    PushFrameDataFuzzTest2,
+    StoreFrameDataFuzzTest,
+    SizeFuzzTest,
+    DataSizeFuzzTest,
+    GetFramesFuzzTest,
+    GetReadPosFuzzTest,
+    GetWritePosFuzzTest,
+    UpdateReadPosFuzzTest,
+    UpdateWritePosFuzzTest,
+    SetBufferValidFuzzTest,
+    SetBufferSilenceFuzzTest,
+    SetBufferStateFuzzTest,
+    GetCurFramesFuzzTest,
+    GetPcmDataBufferFuzzTest,
+    GetFrameSampleFuzzTest,
+    GetSourceBufferTypeFuzzTest,
+    SetSourceBufferTypeFuzzTest,
+    GetSplitStreamTypeFuzzTest,
+    SetSplitStreamTypeFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
\ No newline at end of file
diff --git a/test/fuzztest/audiohpaepcmbuffer_fuzzer/project.xml b/test/fuzztest/audiohpaepcmbuffer_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/audiohpaepcmbuffer_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/audiohpaepcmprocess_fuzzer/BUILD.gn b/test/fuzztest/audiohpaepcmprocess_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..250cf54ccb5a6bedc049ef91c1eee2ac0e14c83d
--- /dev/null
+++ b/test/fuzztest/audiohpaepcmprocess_fuzzer/BUILD.gn
@@ -0,0 +1,104 @@
+# Copyright (c) 2024 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("AudioHpaePcmProcessFuzzTest") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../audiohpaepcmprocess_fuzzer"
+
+  include_dirs = [
+    "../../../frameworks/native/audioadapter/include",
+    "../../../frameworks/native/hdiadapter_new/include/manager",
+    "../../../frameworks/native/hdiadapter_new/include/util",
+    "../../../interfaces/inner_api/native/audiocommon/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_engine/manager/include",
+    "../../../services/audio_policy/server/include/service",
+    "../../../services/audio_engine/simd",
+  ]
+
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "audiohpaepcmprocess_fuzzer.cpp",
+    "../../../frameworks/native/hdiadapter_new/util/id_handler.cpp",
+    "../../../frameworks/native/audioadapter/src/pro_audio_service_adapter.cpp",
+    "../../../services/audio_engine/buffer/hpae_pcm_process.cpp",
+    "../../../services/audio_engine/buffer/hpae_pcm_process.h",
+    ]
+
+  deps = [
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../../services/audio_policy:audio_policy_service",
+    "../../../services/audio_service:audio_common",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":AudioHpaePcmProcessFuzzTest" ]
+}
\ No newline at end of file
diff --git a/test/fuzztest/audiohpaepcmprocess_fuzzer/audiohpaepcmprocess_fuzzer.cpp b/test/fuzztest/audiohpaepcmprocess_fuzzer/audiohpaepcmprocess_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..ae695697eb7e15e5ea6a73ab39f2df3507dd7294
--- /dev/null
+++ b/test/fuzztest/audiohpaepcmprocess_fuzzer/audiohpaepcmprocess_fuzzer.cpp
@@ -0,0 +1,152 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#undef private
+#include "audio_info.h"
+#include "simd_utils.h"
+#include "hpae_pcm_buffer.h"
+#include "hpae_pcm_process.h"
+#include "audio_log.h"
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t)
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+void SizeFuzzTest()
+{
+    std::vector<float> pcmData = {GetData<float>(),GetData<float>(),GetData<float>(),GetData<float>(),GetData<float>()};
+    float *begin = pcmData.data();
+    size_t size_ = pcmData.size();
+    auto hpaePcmProcess = std::make_shared<HpaePcmProcess>(begin,size_);
+    hpaePcmProcess->Size();
+}
+
+void BeginFuzzTest()
+{
+    std::vector<float> pcmData = {GetData<float>(),GetData<float>(),GetData<float>(),GetData<float>(),GetData<float>()};
+    float *begin = pcmData.data();
+    size_t size_ = pcmData.size();
+    auto hpaePcmProcess = std::make_shared<HpaePcmProcess>(begin,size_);
+    hpaePcmProcess->Begin();
+}
+
+void EndFuzzTest()
+{
+    std::vector<float> pcmData = {GetData<float>(),GetData<float>(),GetData<float>(),GetData<float>(),GetData<float>()};
+    float *begin = pcmData.data();
+    size_t size_ = pcmData.size();
+    auto hpaePcmProcess = std::make_shared<HpaePcmProcess>(begin,size_);
+    hpaePcmProcess->End();
+}
+
+void ResetFuzzTest()
+{
+    std::vector<float> pcmData = {GetData<float>(),GetData<float>(),GetData<float>(),GetData<float>(),GetData<float>()};
+    float *begin = pcmData.data();
+    size_t size_ = pcmData.size();
+    auto hpaePcmProcess = std::make_shared<HpaePcmProcess>(begin,size_);
+    hpaePcmProcess->Reset();
+}
+
+void GetErrNoFuzzTest()
+{
+    std::vector<float> pcmData = {GetData<float>(),GetData<float>(),GetData<float>(),GetData<float>(),GetData<float>()};
+    float *begin = pcmData.data();
+    size_t size_ = pcmData.size();
+    auto hpaePcmProcess = std::make_shared<HpaePcmProcess>(begin,size_);
+    hpaePcmProcess->GetErrNo();
+}
+
+typedef void (*TestFuncs[5])();
+
+TestFuncs g_testFuncs = {
+    SizeFuzzTest,
+    BeginFuzzTest,
+    EndFuzzTest,
+    ResetFuzzTest,
+    GetErrNoFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
\ No newline at end of file
diff --git a/test/fuzztest/audiohpaepcmprocess_fuzzer/project.xml b/test/fuzztest/audiohpaepcmprocess_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/audiohpaepcmprocess_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/audiohpaesinkinputnode_fuzzer/BUILD.gn b/test/fuzztest/audiohpaesinkinputnode_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..bb4289dadff2ac98248d39830747cd099800cec2
--- /dev/null
+++ b/test/fuzztest/audiohpaesinkinputnode_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2024 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("AudioHpaeSinkInputNodeFuzzTest") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../audiohpaesinkinputnode_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "audiohpaesinkinputnode_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../..services/audio_service:audio_service,
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":AudioHpaeSinkInputNodeFuzzTest" ]
+}
diff --git a/test/fuzztest/audiohpaesinkinputnode_fuzzer/audiohpaesinkinputnode_fuzzer.cpp b/test/fuzztest/audiohpaesinkinputnode_fuzzer/audiohpaesinkinputnode_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..0c9c828217f2fa690ad71c946a6dc55987b1913c
--- /dev/null
+++ b/test/fuzztest/audiohpaesinkinputnode_fuzzer/audiohpaesinkinputnode_fuzzer.cpp
@@ -0,0 +1,254 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "hpae_msg_channel.h"
+#include "hpae_node.h"
+#include "hpae_pcm_buffer.h"
+#include "audio_info.h"
+#include "i_renderer_stream.h"
+#include "linear_pos_time_model.h"
+
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t)
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->DoProcess();
+}
+
+void ResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->Reset();
+}
+
+void ResetAllFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->ResetAll();
+}
+
+void RegisterWriteCallbackFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    const std::weak_ptr<IStreamCallback> &callback = std::weak_ptr<IStreamCallback>();
+    hpaeSinkInputNode->RegisterWriteCallback(callback);
+}
+
+void FlushFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->Flush();
+}
+
+void DrainFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->Drain();
+}
+
+void SetStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    HpaeSessionState renderState = renderState;
+    hpaeInnerCapturerManager->SetState(renderState);
+}
+
+void GetStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->GetState();
+}
+
+void GetFramesWrittenFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->GetFramesWritten();
+}
+
+void GetCurrentPositionFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    uint64_t p = GetData<uint64_t>();
+    uint64_t &framePosition = p;
+    std::vector<uint64_t> timestamp;
+    hpaeSinkInputNode->GetCurrentPosition(framePosition,timestamp);
+}
+
+void RewindHistoryBufferFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    uint64_t rewindTime = GetData<uint64_t>();
+    hpaeSinkInputNode->RewindHistoryBuffer(rewindTime);
+}
+
+void SetAppUidFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    int32_t appUid = GetData<int32_t>();
+    hpaeSinkInputNode->SetAppUid(appUid);
+}
+
+void GetAppUidFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->GetAppUid(appUid);
+}
+
+void SetOffloadEnabledFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->SetOffloadEnabled(true);
+}
+
+void GetOffloadEnabledFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->GetOffloadEnabled();
+}
+
+void SetLoudnessGainFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    float loudnessGain = GetData<float>();
+    hpaeSinkInputNode->SetLoudnessGain(loudnessGain);
+}
+
+void GetLoudnessGainFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->GetLoudnessGain();
+}
+
+typedef void (*TestFuncs[17])();
+
+TestFuncs g_testFuncs = {
+    DoProcessFuzzTest,
+    ResetFuzzTest,
+    ResetAllFuzzTest,
+    RegisterWriteCallbackFuzzTest,
+    FlushFuzzTest,
+    DrainFuzzTest,
+    SetStateFuzzTest,
+    GetStateFuzzTest,
+    GetFramesWrittenFuzzTest,
+    GetCurrentPositionFuzzTest,
+    RewindHistoryBufferFuzzTest,
+    SetAppUidFuzzTest,
+    GetAppUidFuzzTest,
+    SetOffloadEnabledFuzzTest,
+    GetOffloadEnabledFuzzTest,
+    SetLoudnessGainFuzzTest,
+    GetLoudnessGainFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/audiohpaesinkinputnode_fuzzer/project.xml b/test/fuzztest/audiohpaesinkinputnode_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/audiohpaesinkinputnode_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/audiohpaesinkoutputnode_fuzzer/BUILD.gn b/test/fuzztest/audiohpaesinkoutputnode_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..b429126d295eaf08cc255970dfc75c29f1c00748
--- /dev/null
+++ b/test/fuzztest/audiohpaesinkoutputnode_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2024 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("AudioHpaeSinkOutputNodeFuzzTest") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../audiohpaesinkoutputnode_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "audiohpaesinkoutputnode_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../..services/audio_service:audio_service,
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":AudioHpaeSinkIOutputNodeFuzzTest" ]
+}
diff --git a/test/fuzztest/audiohpaesinkoutputnode_fuzzer/audiohpaesinkoutputnode_fuzzer.cpp b/test/fuzztest/audiohpaesinkoutputnode_fuzzer/audiohpaesinkoutputnode_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..e3184d14f0abd5ba7f889ff8f566afe3ea4c4af2
--- /dev/null
+++ b/test/fuzztest/audiohpaesinkoutputnode_fuzzer/audiohpaesinkoutputnode_fuzzer.cpp
@@ -0,0 +1,287 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "hpae_node.h"
+#include "hpae_pcm_buffer.h"
+#include "audio_info.h"
+#include "sink/i_audio_render_sink.h"
+#include "common/hdi_adapter_info.h"
+#include "manager/hdi_adapter_manager.h"
+#include "high_resolution_timer.h"
+
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t)
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->DoProcess();
+}
+
+void ResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->Reset();
+}
+
+void ResetAllFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->ResetAll();
+}
+
+void ConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeSinkOutputNode->Connect(preNode);
+}
+
+void DisConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeSinkOutputNode->DisConnect(preNode);
+}
+
+void GetRenderSinkInstanceFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    std::string deviceClass = "123";
+    std::string deviceNetId = "456"
+    hpaeSinkOutputNode->GetRenderSinkInstance(deviceClass,deviceNetId);
+}
+
+void RenderSinkInitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    IAudioSinkAttr attr;
+    hpaeSinkOutputNode->RenderSinkInit(attr);
+}
+
+void RenderSinkDeInitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->RenderSinkDeInit();
+}
+
+void RenderSinkFlushFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->RenderSinkFlush();
+}
+
+void RenderSinkPauseFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->RenderSinkPause();
+}
+void RenderSinkResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->RenderSinkReset();
+}
+void RenderSinkResumeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->RenderSinkResume();
+}
+
+void RenderSinkStartFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->RenderSinkStart();
+}
+
+void RenderSinkStopFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->RenderSinkStop();
+}
+
+void RenderSinkSetPriPaPowerFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->RenderSinkSetPriPaPower();
+}
+
+void RenderSinkSetSyncIdFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    int32_t syncId = GetData<uint32_t>();
+    hpaeSinkOutputNode->RenderSinkSetSyncId(syncId);
+}
+
+void GetPreOutNumFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->GetPreOutNum();
+}
+
+void GetSinkStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->GetSinkState();
+}
+
+void SetSinkStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    StreamManagerState sinkState;
+    hpaeSinkOutputNode->SetSinkState(sinkState);
+}
+
+void UpdateAppsUidFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    const std::vector<int32_t> &appsUid = GetData<uint32_t>();
+    hpaeSinkOutputNode->UpdateAppsUid(appsUid);
+}
+
+void GetLatencyFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkOutputNode = std::make_shared<HpaeSinkOutputNode>(nodeInfo);
+    hpaeSinkOutputNode->GetLatency();
+}
+
+typedef void (*TestFuncs[21])();
+
+TestFuncs g_testFuncs = {
+    DoProcessFuzzTest,
+    ResetFuzzTest,
+    ResetAllFuzzTest,
+    ConnectFuzzTest,
+    DisConnectFuzzTest,
+    GetRenderSinkInstanceFuzzTest,
+    RenderSinkInitFuzzTest,
+    RenderSinkDeInitFuzzTest,
+    RenderSinkFlushFuzzTest,
+    RenderSinkPauseFuzzTest,
+    RenderSinkResetFuzzTest,
+    RenderSinkResumeFuzzTest,
+    RenderSinkStartFuzzTest,
+    RenderSinkStopFuzzTest,
+    RenderSinkSetPriPaPowerFuzzTest,
+    RenderSinkSetSyncIdFuzzTest,
+    GetPreOutNumFuzzTest,
+    GetSinkStateFuzzTest,
+    SetSinkStateFuzzTest,
+    UpdateAppsUidFuzzTest,
+    GetLatencyFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/audiohpaesinkoutputnode_fuzzer/project.xml b/test/fuzztest/audiohpaesinkoutputnode_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/audiohpaesinkoutputnode_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/audiohpaesourceinputnode_fuzzer/BUILD.gn b/test/fuzztest/audiohpaesourceinputnode_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..ee1489a497581a900aeb2726a790f984dcfe3647
--- /dev/null
+++ b/test/fuzztest/audiohpaesourceinputnode_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2024 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("AudioHpaeSourceInputNodeFuzzTest") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../audiohpaesourceinputnode_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "audiohpaesourceinputnode_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../..services/audio_service:audio_service,
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":AudioHpaeSourceInputNodeFuzzTest" ]
+}
diff --git a/test/fuzztest/audiohpaesourceinputnode_fuzzer/audiohpaesourceinputnode_fuzzer.cpp b/test/fuzztest/audiohpaesourceinputnode_fuzzer/audiohpaesourceinputnode_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..088fd2b89c17611be7576df52f9a88cf3c6e8921
--- /dev/null
+++ b/test/fuzztest/audiohpaesourceinputnode_fuzzer/audiohpaesourceinputnode_fuzzer.cpp
@@ -0,0 +1,306 @@
+/*
+ * Copyright (c) 2024 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "hpae_node.h"
+#include "hpae_pcm_buffer.h"
+#include "source/i_audio_capture_source.h"
+#include "common/hdi_adapter_type.h"
+#include "common/hdi_adapter_info.h"
+#include "manager/hdi_adapter_manager.h"
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t)
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->DoProcess();
+}
+
+void ResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->Reset();
+}
+
+void ResetAllFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->ResetAll();
+}
+
+void GetSharedInstanceFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->GetSharedInstance(callback);
+}
+
+void GetOutputPortBufferTypeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    HpaeNodeInfo nodeInfo;
+    hpaeSinkInputNode->GetOutputPortBufferType(nodeInfo);
+}
+
+void GetCapturerSourceInstanceFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    const std::string &deviceClass = nodeInfo.deviceClass;
+    const std::string &deviceNetId = nodeInfo.deviceNetId;
+    const std::string &sourceType = nodeInfo.sourceType;
+    const std::string &sourceName = nodeInfo.sourceName;
+    hpaeSinkInputNode->GetCapturerSourceInstance(deviceClass,deviceNetId,sourceType,sourceName);
+}
+
+void CapturerSourceInitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    IAudioSourceAttr attr;
+    hpaeSinkInputNode->CapturerSourceInit(attr);
+}
+
+void CapturerSourceDeInitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->CapturerSourceDeInit();
+}
+
+void CapturerSourceFlushFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->CapturerSourceFlush();
+}
+
+void CapturerSourcePauseFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->CapturerSourcePause();
+}
+
+void CapturerSourceResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->CapturerSourceReset();
+}
+
+void CapturerSourceResumeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->CapturerSourceResume();
+}
+
+void CapturerSourceStartFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->CapturerSourceStart();
+}
+
+void CapturerSourceStopFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->CapturerSourceStop();
+}
+
+void GetSourceStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->GetSourceState();
+}
+
+void SetSourceStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    StreamManagerState sourceState;
+    hpaeSinkInputNode->SetSourceState(sourceState);
+}
+
+void WriteCapturerDataFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    char *data = NULL;
+    int32_t dataSize = GetData<int32_t>();
+    hpaeSinkInputNode->WriteCapturerData(data,dataSize);
+}
+
+void GetOutputPortNumFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->GetOutputPortNum();
+}
+
+void GetSourceInputNodeTypeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->GetSourceInputNodeType();
+}
+
+void SetSourceInputNodeTypeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    HpaeSourceInputNodeType type;
+    hpaeSinkInputNode->SetSourceInputNodeType(type);
+}
+
+void GetNodeInfoWithInfoFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    HpaeSourceBufferType type;
+    hpaeSinkInputNode->GetNodeInfoWithInfo(type);
+}
+
+void UpdateAppsUidAndSessionIdFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    std::vector<int32_t> &appsUid = GetData<int32_t>();
+    std::vector<int32_t> &sessionsId = GetData<int32_t>();
+    hpaeSinkInputNode->UpdateAppsUidAndSessionId(appsUid,sessionsId);
+}
+
+void GetCaptureIdFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSinkInputNode = std::make_shared<HpaeSinkInputNode>(nodeInfo);
+    hpaeSinkInputNode->GetCaptureIdSessionId();
+}
+
+typedef void (*TestFuncs[23])();
+
+TestFuncs g_testFuncs = {
+    DoProcessFuzzTest,
+    ResetFuzzTest,
+    ResetAllFuzzTest,
+    GetSharedInstanceFuzzTest,
+    GetOutputPortBufferTypeFuzzTest,
+    GetCapturerSourceInstanceFuzzTest,
+    CapturerSourceInitFuzzTest,
+    CapturerSourceDeInitFuzzTest,
+    CapturerSourceFlushFuzzTest,
+    CapturerSourcePauseFuzzTest,
+    CapturerSourceResetFuzzTest,
+    CapturerSourceResumeFuzzTest,
+    CapturerSourceStartFuzzTest,
+    CapturerSourceStopFuzzTest,
+    GetSourceStateFuzzTest,
+    SetSourceStateFuzzTest,
+    WriteCapturerDataFuzzTest,
+    GetOutputPortNumFuzzTest,
+    GetSourceInputNodeTypeFuzzTest,
+    SetSourceInputNodeTypeFuzzTest,
+    GetNodeInfoWithInfoFuzzTest,
+    UpdateAppsUidAndSessionIdFuzzTest,
+    GetCaptureIdFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/audiohpaesourceinputnode_fuzzer/project.xml b/test/fuzztest/audiohpaesourceinputnode_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/audiohpaesourceinputnode_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/hpaeoutputcluster_fuzzer/BUILD.gn b/test/fuzztest/hpaeoutputcluster_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..8c14b5b0d688ba82fb73fc34bd1f746a5bf8d7d3
--- /dev/null
+++ b/test/fuzztest/hpaeoutputcluster_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("HpaeOutputClusterFuzzTest") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../hpaeoutputcluster_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "hpaeoutputcluster_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../..services/audio_service:audio_service,
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":HpaeOutputClusterFuzzTest" ]
+}
diff --git a/test/fuzztest/hpaeoutputcluster_fuzzer/hpaeoutputcluster_fuzzer.cpp b/test/fuzztest/hpaeoutputcluster_fuzzer/hpaeoutputcluster_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..c48a9de0366d26695b91e98bc79d9e24a0e11d2f
--- /dev/null
+++ b/test/fuzztest/hpaeoutputcluster_fuzzer/hpaeoutputcluster_fuzzer.cpp
@@ -0,0 +1,302 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "hpae_mixer_node.h"
+#include "hpae_sink_output_node.h"
+#include "hpae_audio_format_converter_node.h"
+
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t);
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->DoProcess();
+}
+
+void ResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->Reset();
+}
+
+void ResetAllFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->ResetAll();
+}
+
+void ConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeOutputCluster->Connect(preNode);
+}
+
+void DisConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeOutputCluster->DisConnect(preNode);
+}
+
+void GetConverterNodeCountFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->GetConverterNodeCount();
+}
+
+void GetPreOutNumFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->GetPreOutNum();
+}
+
+void GetInstanceFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    std::string deviceClass = "";
+    std::string deviceNetId = "";
+    hpaeOutputCluster->GetInstance(deviceClass,deviceNetId);
+}
+
+void InitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    IAudioSinkAttr attr;
+    hpaeOutputCluster->Init(attr);
+}
+
+void DeInitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->DeInit();
+}
+
+void FlushFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->Flush();
+}
+
+void PauseFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->Pause();
+}
+
+void ResetRenderFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->ResetRender();
+}
+
+void ResumeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->Resume();
+}
+
+void StartFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->Start();
+}
+
+void StopFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->Stop();
+}
+
+void SetTimeoutStopThdFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    uint32_t timeoutThdMs = GetData<uint32_t>();
+    hpaeOutputCluster->SetTimeoutStopThd();
+}
+
+void GetStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->GetState();
+}
+
+void IsProcessClusterConnectedFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    HpaeProcessorType sceneType;
+    hpaeOutputCluster->IsProcessClusterConnected(sceneType);
+}
+
+void UpdateAppsUidFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    const std::vector<int32_t> &appsUid = GetData<uint32_t>();
+    hpaeOutputCluster->UpdateAppsUid(appsUid);
+}
+
+void SetPriPaPowerFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->SetPriPaPower();
+}
+
+void SetSyncIdFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    int32_t syncId = GetData<int32_t>();
+    hpaeOutputCluster->SetSyncId(syncId);
+}
+
+void GetLatencyFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeOutputCluster = std::make_shared<HpaeOutputCluster>(nodeInfo);
+    hpaeOutputCluster->GetLatency();
+}
+
+typedef void (*TestFuncs[23])();
+
+TestFuncs g_testFuncs = {
+    DoProcessFuzzTest,
+    ResetFuzzTest,
+    ResetAllFuzzTest,
+    ConnectFuzzTest,
+    DisConnectFuzzTest,
+    GetConverterNodeCountFuzzTest,
+    GetPreOutNumFuzzTest,
+    GetInstanceFuzzTest,
+    InitFuzzTest,
+    DeInitFuzzTest,
+    FlushFuzzTest,
+    PauseFuzzTest,
+    ResetRenderFuzzTest,
+    ResumeFuzzTest,
+    StartFuzzTest,
+    StopFuzzTest,
+    SetTimeoutStopThdFuzzTest,
+    GetStateFuzzTest,
+    IsProcessClusterConnectedFuzzTest,
+    UpdateAppsUidFuzzTest,
+    SetPriPaPowerFuzzTest,
+    SetSyncIdFuzzTest,
+    GetLatencyFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/hpaeoutputcluster_fuzzer/project.xml b/test/fuzztest/hpaeoutputcluster_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..66e1dcac475475fb101b6f8670ec699e6e9696aa
--- /dev/null
+++ b/test/fuzztest/hpaeoutputcluster_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2025 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/hpaeprocesscluster_fuzzer/BUILD.gn b/test/fuzztest/hpaeprocesscluster_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..91972729faefb7828f11d202a0c2905447347ccd
--- /dev/null
+++ b/test/fuzztest/hpaeprocesscluster_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("HpaeProcessCluster") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../hpaeprocesscluster_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "hpaeprocesscluster_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../../services/audio_service:audio_service",
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":HpaeProcessCluster" ]
+}
diff --git a/test/fuzztest/hpaeprocesscluster_fuzzer/hpaeprocesscluster_fuzzer.cpp b/test/fuzztest/hpaeprocesscluster_fuzzer/hpaeprocesscluster_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..765e52a56594b6d1a6b7fd29b2b1839d31ea77f8
--- /dev/null
+++ b/test/fuzztest/hpaeprocesscluster_fuzzer/hpaeprocesscluster_fuzzer.cpp
@@ -0,0 +1,295 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "hpae_process_cluster.h"
+#include "test_case_common.h"
+#include "audio_errors.h"
+#include "hpae_sink_input_node.h"
+#include "hpae_sink_output_node.h"
+#include "audio_effect.h"
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t);
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->DoProcess();
+}
+
+void ResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->Reset();
+}
+
+void ResetAllFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->ResetAll();
+}
+
+void GetSharedInstanceFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->GetSharedInstance();
+}
+
+void GetOutputPortFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->GetOutputPort();
+}
+
+void ConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeProcessCluster->Connect(preNode);
+}
+
+void DisConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeProcessCluster->DisConnect(preNode);
+}
+
+void GetGainNodeCountFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->GetGainNodeCount();
+}
+
+void GetConverterNodeCountFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->GetConverterNodeCount();
+}
+
+void GetPreOutNumFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->GetPreOutNum();
+}
+
+void AudioRendererCreateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->AudioRendererCreate(nodeInfo);
+}
+
+void AudioRendererStartFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->AudioRendererStart(nodeInfo);
+}
+
+void AudioRendererStopFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->AudioRendererStop(nodeInfo);
+}
+
+void AudioRendererReleaseFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->AudioRendererRelease(nodeInfo);
+}
+
+void GetNodeInputFormatInfoFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    AudioBasicFormat basicFormat;
+    hpaeProcessCluster->GetNodeInputFormatInfo(sessionId,basicFormat);
+}
+
+void GetGainNodeByIdFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    uint32_t id = GetData<uint32_t>();
+    hpaeProcessCluster->GetGainNodeById(id);
+}
+
+void GetConverterNodeByIdFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    uint32_t id = GetData<uint32_t>();
+    hpaeProcessCluster->GetConverterNodeById(id);
+}
+
+void SetConnectedFlagFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->SetConnectedFlag(true);
+}
+
+void GetConnectedFlagFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->GetConnectedFlag();
+}
+
+void SetupAudioLimiterFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->SetupAudioLimiter();
+}
+
+void SetLoudnessGainFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    uint32_t sessionId = GetData<uint32_t>();
+    float loudnessGain = GetData<float>();
+    hpaeProcessCluster->SetLoudnessGain(sessionId,oudnessGain);
+}
+
+void DisConnectMixerNodeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeProcessCluster = std::make_shared<HpaeProcessCluster>(nodeInfo);
+    hpaeProcessCluster->DisConnectMixerNode();
+}
+
+typedef void (*TestFuncs[22])();
+
+TestFuncs g_testFuncs = {
+    DoProcessFuzzTest,
+    ResetFuzzTest,
+    ResetAllFuzzTest,
+    GetSharedInstanceFuzzTest,
+    GetOutputPortFuzzTest,
+    ConnectFuzzTest,
+    DisConnectFuzzTest,
+    GetGainNodeCountFuzzTest,
+    GetConverterNodeCountFuzzTest,
+    GetPreOutNumFuzzTest,
+    AudioRendererCreateFuzzTest,
+    AudioRendererStartFuzzTest,
+    AudioRendererStopFuzzTest,
+    AudioRendererReleaseFuzzTest,
+    GetNodeInputFormatInfoFuzzTest,
+    GetGainNodeByIdFuzzTest,
+    GetConverterNodeByIdFuzzTest,
+    SetConnectedFlagFuzzTest,
+    GetConnectedFlagFuzzTest,
+    SetupAudioLimiterFuzzTest,
+    SetLoudnessGainFuzzTest,
+    DisConnectMixerNodeFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/hpaeprocesscluster_fuzzer/project.xml b/test/fuzztest/hpaeprocesscluster_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/hpaeprocesscluster_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/hpaeremoteoutputcluster_fuzzer/BUILD.gn b/test/fuzztest/hpaeremoteoutputcluster_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..5c5f412a050c9211e70d7148c73511d5d5e75fdb
--- /dev/null
+++ b/test/fuzztest/hpaeremoteoutputcluster_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("HpaeRemoteOutputCluster") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../hpaeremoteoutputcluster_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "hpaeremoteoutputcluster_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../../services/audio_service:audio_service",
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":HpaeRemoteOutputCluster" ]
+}
diff --git a/test/fuzztest/hpaeremoteoutputcluster_fuzzer/hpaeremoteoutputcluster_fuzzer.cpp b/test/fuzztest/hpaeremoteoutputcluster_fuzzer/hpaeremoteoutputcluster_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..e473cfd2ee25a2cb4ee7a603344081f1c801e26a
--- /dev/null
+++ b/test/fuzztest/hpaeremoteoutputcluster_fuzzer/hpaeremoteoutputcluster_fuzzer.cpp
@@ -0,0 +1,287 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "hpae_process_cluster.h"
+#include "test_case_common.h"
+#include "audio_errors.h"
+#include "hpae_sink_input_node.h"
+#include "hpae_remote_output_cluster.h"
+#include "hpae_mixer_node.h"
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t);
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->DoProcess();
+}
+
+void ResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->Reset();
+}
+
+void ResetAllFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->ResetAll();
+}
+
+void ConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeRemoteOutputCluster->Connect(preNode);
+}
+
+void DisConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeRemoteOutputCluster->DisConnect(preNode);
+}
+
+void GetConverterNodeCountFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->GetConverterNodeCount();
+}
+
+void GetPreOutNumFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->GetPreOutNum();
+}
+
+void GetInstanceFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    std::string deviceClass = "123";
+    std::string deviceNetId = "456";
+    hpaeRemoteOutputCluster->GetInstance(deviceClass,deviceNetId);
+}
+
+void InitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    IAudioSinkAttr attr;
+    hpaeRemoteOutputCluster->Init(attr);
+}
+
+void DeInitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->DeInit();
+}
+
+void FlushFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->Flush();
+}
+
+void PauseFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->Pause();
+}
+
+void ResetRenderFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->ResetRender();
+}
+
+void ResumeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->Resume();
+}
+
+void StartFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->Start();
+}
+
+void StopFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->Stop();
+}
+
+void SetTimeoutStopThdFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    uint32_t timeoutThdMs = GetData<uint32_t>();
+    hpaeRemoteOutputCluster->SetTimeoutStopThd(timeoutThdMs);
+}
+
+void GetFrameDataFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->GetFrameData();
+}
+
+void GetStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    hpaeRemoteOutputCluster->GetState();
+}
+
+void IsProcessClusterConnectedFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    HpaeProcessorType sceneType;
+    hpaeRemoteOutputCluster->IsProcessClusterConnected(sceneType);
+}
+
+void UpdateAppsUidFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteOutputCluster = std::make_shared<HpaeRemoteOutputCluster>(nodeInfo);
+    const std::vector<int32_t> appsUid = {Getdata<int32_t>()};
+    hpaeRemoteOutputCluster->UpdateAppsUid(appsUid);
+}
+
+typedef void (*TestFuncs[21])();
+
+TestFuncs g_testFuncs = {
+    DoProcessFuzzTest,
+    ResetFuzzTest,
+    ResetAllFuzzTest,
+    ConnectFuzzTest,
+    DisConnectFuzzTest,
+    GetConverterNodeCountFuzzTest,
+    GetPreOutNumFuzzTest,
+    GetInstanceFuzzTest,
+    InitFuzzTest,
+    DeInitFuzzTest,
+    FlushFuzzTest,
+    PauseFuzzTest,
+    ResetRenderFuzzTest,
+    ResumeFuzzTest,
+    StartFuzzTest,
+    StopFuzzTest,
+    SetTimeoutStopThdFuzzTest,
+    GetFrameDataFuzzTest,
+    GetStateFuzzTest,
+    IsProcessClusterConnectedFuzzTest,
+    UpdateAppsUidFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/hpaeremoteoutputcluster_fuzzer/project.xml b/test/fuzztest/hpaeremoteoutputcluster_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/hpaeremoteoutputcluster_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/hpaeremotesinkoutputnode_fuzzer/BUILD.gn b/test/fuzztest/hpaeremotesinkoutputnode_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..1f48326653aa31c978e664ed450f32079281784a
--- /dev/null
+++ b/test/fuzztest/hpaeremotesinkoutputnode_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("HpaeRemoteSinkOutputNode") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../hpaeremotesinkoutputnode_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "hpaeremotesinkoutputnode_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../../services/audio_service:audio_service",
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":HpaeRemoteSinkOutputNode" ]
+}
diff --git a/test/fuzztest/hpaeremotesinkoutputnode_fuzzer/hpaeremotesinkoutputnode_fuzzer.cpp b/test/fuzztest/hpaeremotesinkoutputnode_fuzzer/hpaeremotesinkoutputnode_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..a42fb9fcf6439a64da55a08a116e474f098033e7
--- /dev/null
+++ b/test/fuzztest/hpaeremotesinkoutputnode_fuzzer/hpaeremotesinkoutputnode_fuzzer.cpp
@@ -0,0 +1,271 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "hpae_process_cluster.h"
+#include "test_case_common.h"
+#include "audio_errors.h"
+#include "hpae_sink_input_node.h"
+#include "hpae_remote_sink_output_node.h"
+#include "hpae_mixer_node.h"
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t);
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->DoProcess();
+}
+
+void ResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->Reset();
+}
+
+void ResetAllFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->ResetAll();
+}
+
+void ConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeRemoteSinkOutputNode->Connect(preNode);
+}
+
+void DisConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeRemoteSinkOutputNode->DisConnect(preNode);
+}
+
+void GetRenderSinkInstanceFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    std::string deviceClass = "123";
+    std::string deviceNetId = "456";
+    hpaeRemoteSinkOutputNode->GetRenderSinkInstance(deviceClass,deviceNetId);
+}
+
+void RenderSinkInitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    IAudioSinkAttr attr;
+    hpaeRemoteSinkOutputNode->RenderSinkInit(attr);
+}
+
+void RenderSinkDeInitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->RenderSinkDeInit();
+}
+
+void RenderSinkFlushFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->RenderSinkFlush();
+}
+
+void RenderSinkPauseFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->RenderSinkPause();
+}
+
+void RenderSinkResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->RenderSinkReset();
+}
+
+void RenderSinkResumeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->RenderSinkResume();
+}
+
+void RenderSinkStartFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->RenderSinkStart();
+}
+
+void RenderSinkStopFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->RenderSinkStop();
+}
+
+void GetPreOutNumFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->GetPreOutNum();
+}
+
+void GetRenderFrameDataFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->GetRenderFrameData();
+}
+
+void GetSinkStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    hpaeRemoteSinkOutputNode->GetSinkState();
+}
+
+void SetSinkStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    StreamManagerState sinkState;
+    hpaeRemoteSinkOutputNode->SetSinkState(sinkState);
+}
+
+void UpdateAppsUidFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRemoteSinkOutputNode = std::make_shared<HpaeRemoteSinkOutputNode>(nodeInfo);
+    const std::vector<int32_t> appsUid = {GetData<int32_t>()};
+    hpaeRemoteSinkOutputNode->UpdateAppsUid(appsUid);
+}
+
+
+typedef void (*TestFuncs[19])();
+
+TestFuncs g_testFuncs = {
+    DoProcessFuzzTest,
+    ResetFuzzTest,
+    ResetAllFuzzTest,
+    ConnectFuzzTest,
+    DisConnectFuzzTest,
+    GetRenderSinkInstanceFuzzTest,
+    RenderSinkInitFuzzTest,
+    RenderSinkDeInitFuzzTest,
+    RenderSinkFlushFuzzTest,
+    RenderSinkPauseFuzzTest,
+    RenderSinkResetFuzzTest,
+    RenderSinkResumeFuzzTest,
+    RenderSinkStartFuzzTest,
+    RenderSinkStopFuzzTest,
+    GetPreOutNumFuzzTest,
+    GetRenderFrameDataFuzzTest,
+    GetSinkStateFuzzTest,
+    SetSinkStateFuzzTest,
+    UpdateAppsUidFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/hpaeremotesinkoutputnode_fuzzer/project.xml b/test/fuzztest/hpaeremotesinkoutputnode_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/hpaeremotesinkoutputnode_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/hpaerendereffectnode_fuzzer/BUILD.gn b/test/fuzztest/hpaerendereffectnode_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..d5ce841d34953218c9b12051b9ac95558b1faa93
--- /dev/null
+++ b/test/fuzztest/hpaerendereffectnode_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("HpaeRenderEffectNode") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../hpaerendereffectnode_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "hpaerendereffectnode_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../../services/audio_service:audio_service",
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":HpaeRenderEffectNode" ]
+}
diff --git a/test/fuzztest/hpaerendereffectnode_fuzzer/hpaerendereffectnode_fuzzer.cpp b/test/fuzztest/hpaerendereffectnode_fuzzer/hpaerendereffectnode_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..1d017082e0d9e5f577e50342dabce270a9502710
--- /dev/null
+++ b/test/fuzztest/hpaerendereffectnode_fuzzer/hpaerendereffectnode_fuzzer.cpp
@@ -0,0 +1,158 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "hpae_sink_input_node.h"
+#include "hpae_render_effect_node.h"
+#include "hpae_sink_output_node.h"
+#include "hpae_source_input_node.h"
+#include "audio_errors.h"
+#include "audio_effect_chain_manager.h"
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t);
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRenderEffectNode = std::make_shared<HpaeRenderEffectNode>(nodeInfo);
+    hpaeRenderEffectNode->DoProcess();
+}
+
+void AudioRendererCreateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRenderEffectNode = std::make_shared<HpaeRenderEffectNode>(nodeInfo);
+    hpaeRenderEffectNode->AudioRendererCreate(nodeInfo);
+}
+
+void AudioRendererStartFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRenderEffectNode = std::make_shared<HpaeRenderEffectNode>(nodeInfo);
+    hpaeRenderEffectNode->AudioRendererStart(nodeInfo);
+}
+
+void AudioRendererStopFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRenderEffectNode = std::make_shared<HpaeRenderEffectNode>(nodeInfo);
+    hpaeRenderEffectNode->AudioRendererStop(nodeInfo);
+}
+
+void AudioRendererReleaseFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRenderEffectNode = std::make_shared<HpaeRenderEffectNode>(nodeInfo);
+    hpaeRenderEffectNode->AudioRendererRelease(nodeInfo);
+}
+
+void GetExpectedInputChannelInfoFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeRenderEffectNode = std::make_shared<HpaeRenderEffectNode>(nodeInfo);
+    AudioBasicFormat basicFormat;
+    hpaeRenderEffectNode->GetExpectedInputChannelInfo(basicFormat);
+}
+
+typedef void (*TestFuncs[6])();
+
+TestFuncs g_testFuncs = {
+    DoProcessFuzzTest,
+    AudioRendererCreateFuzzTest,
+    AudioRendererStartFuzzTest,
+    AudioRendererStopFuzzTest,
+    AudioRendererReleaseFuzzTest,
+    GetExpectedInputChannelInfoFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/hpaerendereffectnode_fuzzer/project.xml b/test/fuzztest/hpaerendereffectnode_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/hpaerendereffectnode_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/hpaesourceinputcluster_fuzzer/BUILD.gn b/test/fuzztest/hpaesourceinputcluster_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..7b7729f13ee2a4b1ff0314dc1273e28b3ec4da7c
--- /dev/null
+++ b/test/fuzztest/hpaesourceinputcluster_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("HpaeSourceInputCluster") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../hpaesourceinputcluster_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "hpaesourceinputcluster_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../../services/audio_service:audio_service",
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":HpaeSourceInputCluster" ]
+}
diff --git a/test/fuzztest/hpaesourceinputcluster_fuzzer/hpaesourceinputcluster_fuzzer.cpp b/test/fuzztest/hpaesourceinputcluster_fuzzer/hpaesourceinputcluster_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..537590d1c5eeaef31606ded86e5fff122412bd33
--- /dev/null
+++ b/test/fuzztest/hpaesourceinputcluster_fuzzer/hpaesourceinputcluster_fuzzer.cpp
@@ -0,0 +1,300 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "hpae_source_input_cluster.h"
+#include "audio_errors.h"
+#include "hpae_source_input_node.h"
+#include "hpae_source_output_node.h"
+#include "hpae_format_convert.h"
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t);
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->DoProcess();
+}
+
+void ResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->Reset();
+}
+
+void ResetAllFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->ResetAll();
+}
+
+void GetSharedInstanceFuzzTest1()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->GetSharedInstance();
+}
+
+void GetSharedInstanceFuzzTest2()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->GetSharedInstance(nodeInfo);
+}
+
+void GetOutputPortFuzzTest1()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->GetOutputPort();
+}
+
+void GetOutputPortFuzzTest2()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->GetOutputPort(nodeInfo);
+}
+
+void GetCapturerSourceInstanceFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    const std::string deviceClass = nodeInfo.deviceClass;
+    const std::string deviceNetId = nodeInfo.deviceNetId;
+    const SourceType sourceType;
+    const std::string sourceName = nodeInfo.sourceName;
+    hpaeSourceInputCluster->GetCapturerSourceInstance(deviceClass,deviceNetId,sourceType,sourceName);
+}
+
+void GetOutputPortFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    IAudioSourceAttr attr;
+    hpaeSourceInputCluster->GetOutputPort(attr);
+}
+
+void CapturerSourceDeInitFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->CapturerSourceDeInit();
+}
+
+void CapturerSourceFlushFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->CapturerSourceFlush();
+}
+
+void CapturerSourcePauseFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->CapturerSourcePause();
+}
+
+void CapturerSourceResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->CapturerSourceReset();
+}
+
+void CapturerSourceResumeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->CapturerSourceResume();
+}
+
+void CapturerSourceStartFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->CapturerSourceStart();
+}
+
+void CapturerSourceStopFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->CapturerSourceStop();
+}
+
+void GetSourceStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->GetSourceState();
+}
+
+void GetOutputPortNumFuzzTest1()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->GetOutputPortNum();
+}
+
+void GetOutputPortNumFuzzTest2()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->GetOutputPortNum(nodeInfo);
+}
+
+void GetSourceInputNodeTypeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->GetSourceInputNodeType();
+}
+
+void GSetSourceInputNodeTypeFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    HpaeSourceInputNodeType type = HpaeSourceInputNodeType::HPAE_SOURCE_DEFAULT;
+    hpaeSourceInputCluster->SetSourceInputNodeType(type);
+}
+
+void UpdateAppsUidAndSessionIdFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    std::vector<int32_t> appsUid = {GetData<int32_t>()};
+    std::vector<int32_t> sessionsId = {GetData<int32_t>()};
+    hpaeSourceInputCluster->UpdateAppsUidAndSessionId(appsUid,sessionsId);
+}
+
+void GetCaptureIdFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceInputCluster = std::make_shared<HpaeSourceInputCluster>(nodeInfo);
+    hpaeSourceInputCluster->GetCaptureId();
+}
+
+typedef void (*TestFuncs[23])();
+
+TestFuncs g_testFuncs = {
+    DoProcessFuzzTest,
+    ResetFuzzTest,
+    ResetAllFuzzTest,
+    GetSharedInstanceFuzzTest1,
+    GetSharedInstanceFuzzTest2,
+    GetOutputPortFuzzTest1,
+    GetOutputPortFuzzTest2,
+    GetCapturerSourceInstanceFuzzTest,
+    GetOutputPortFuzzTest,
+    CapturerSourceDeInitFuzzTest,
+    CapturerSourceFlushFuzzTest,
+    CapturerSourcePauseFuzzTest,
+    CapturerSourceResetFuzzTest,
+    CapturerSourceResumeFuzzTest,
+    CapturerSourceStartFuzzTest,
+    CapturerSourceStopFuzzTest,
+    GetSourceStateFuzzTest,
+    GetOutputPortNumFuzzTest1,
+    GetOutputPortNumFuzzTest2,
+    GetSourceInputNodeTypeFuzzTest,
+    GSetSourceInputNodeTypeFuzzTest,
+    UpdateAppsUidAndSessionIdFuzzTest,
+    GetCaptureIdFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/hpaesourceinputcluster_fuzzer/project.xml b/test/fuzztest/hpaesourceinputcluster_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/hpaesourceinputcluster_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
diff --git a/test/fuzztest/hpaesourceoutputnode_fuzzer/BUILD.gn b/test/fuzztest/hpaesourceoutputnode_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000000000000000000000000000000..059d47287bf8c311056de7e4c42c97a4353fe83a
--- /dev/null
+++ b/test/fuzztest/hpaesourceoutputnode_fuzzer/BUILD.gn
@@ -0,0 +1,101 @@
+# Copyright (c) 2025 Huawei Device Co., Ltd.
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#     http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+import("//build/config/features.gni")
+import("//build/test.gni")
+import("../../../accessibility.gni")
+import("../../../config.gni")
+
+ohos_fuzztest("HpaeSourceOutputNodeFuzzTest") {
+  module_out_path = "audio_framework/audio_framework_engine"
+  fuzz_config_file = "../hpaesourceoutputnode_fuzzer"
+
+  include_dirs = [
+    "../../../services/audio_engine/dfx",
+    "../../../services/audio_engine/utils",
+    "../../../services/audio_engine/plugin/channel_converter/include",
+    "../../../services/audio_engine/plugin/resample/include",
+    "../../../services/audio_engine/node/include",
+    "../../../services/audio_engine/buffer",
+    "../../../services/audio_service/common/include/limiter",
+    "../../../services/audio_service/server/include",
+    "../../../services/audio_engine/manager/include",
+  ]
+  cflags = [
+    "-g",
+    "-O0",
+    "-Wno-unused-variable",
+    "-fno-omit-frame-pointer",
+    "-fno-access-control",
+  ]
+
+  configs = [ "../../../services/audio_policy:audio_policy_public_config" ]
+
+  sources = [ 
+    "hpaesourceoutputnode_fuzzer.cpp",
+    ]
+
+  deps = [
+    "../../../services/audio_engine:audio_engine_node",
+    "../../../services/audio_engine:audio_engine_manager",
+    "../../..services/audio_service:audio_service,
+    "../../../frameworks/native/audioutils:audio_utils",
+    "../../../frameworks/native/audioschedule:audio_schedule",
+  ]
+
+  external_deps = [
+    "ability_base:want",
+    "ability_runtime:extension_manager",
+    "ability_runtime:wantagent_innerkits",
+    "access_token:libaccesstoken_sdk",
+    "access_token:libprivacy_sdk",
+    "access_token:libtokensetproc_shared",
+    "background_task_mgr:bgtaskmgr_innerkits",
+    "bundle_framework:appexecfwk_base",
+    "bundle_framework:appexecfwk_core",
+    "c_utils:utils",
+    "data_share:datashare_common",
+    "data_share:datashare_consumer",
+    "hdf_core:libhdf_ipc_adapter",
+    "hdf_core:libhdi",
+    "hdf_core:libpub_utils",
+    "hilog:libhilog",
+    "hisysevent:libhisysevent",
+    "ipc:ipc_single",
+    "kv_store:distributeddata_inner",
+    "media_foundation:media_monitor_client",
+    "media_foundation:media_monitor_common",
+    "os_account:os_account_innerkits",
+    "power_manager:powermgr_client",
+    "pulseaudio:pulse",
+    "safwk:system_ability_fwk",
+    "samgr:samgr_proxy",
+  ]
+
+  if (accessibility_enable == true) {
+    external_deps += [
+      "accessibility:accessibility_common",
+      "accessibility:accessibilityconfig",
+    ]
+  }
+
+defines = []
+  if (use_libfuzzer || use_clang_coverage) {
+    defines += [ "TEST_COVERAGE" ]
+  }
+}
+
+group("fuzztest") {
+  testonly = true
+  deps = [ ":HpaeSourceOutputNodeFuzzTest" ]
+}
diff --git a/test/fuzztest/hpaesourceoutputnode_fuzzer/hpaesourceoutputnode_fuzzer.cpp b/test/fuzztest/hpaesourceoutputnode_fuzzer/hpaesourceoutputnode_fuzzer.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..2ffe7a477512f90fdc034c174f55cbbc4a09ce04
--- /dev/null
+++ b/test/fuzztest/hpaesourceoutputnode_fuzzer/hpaesourceoutputnode_fuzzer.cpp
@@ -0,0 +1,216 @@
+/*
+ * Copyright (c) 2025 Huawei Device Co., Ltd.
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+#include <iostream>
+#include <cstddef>
+#include <cstdint>
+#include <vector>
+#include <memory>
+#include <queue>
+#include <string>
+#undef private
+#include "hpae_node.h"
+#include "hpae_pcm_buffer.h"
+#include "audio_info.h"
+#include "i_capturer_stream.h"
+using namespace std;
+using namespace OHOS::AudioStandard::HPAE;
+
+
+namespace OHOS {
+namespace AudioStandard {
+using namespace std;
+static const uint8_t *RAW_DATA = nullptr;
+static size_t g_dataSize = 0;
+static size_t g_pos;
+const size_t THRESHOLD = 10;
+typedef void (*TestPtr)(const uint8_t *,size_t);
+
+template<class T>
+T GetData()
+{
+    T object {};
+    size_t objectSize = sizeof(object);
+    if (RAW_DATA == nullptr || objectSize > g_dataSize - g_pos) {
+        return object;
+    }
+    errno_t ret = memcpy_s(&object, objectSize, RAW_DATA + g_pos, objectSize);
+    if (ret != EOK) {
+        return {};
+    }
+    g_pos += objectSize;
+    return object;
+}
+
+template<class T>
+uint32_t GetArrLength(T& arr)
+{
+    if (arr == nullptr) {
+        AUDIO_INFO_LOG("%{public}s: The array length is equal to 0", __func__);
+        return 0;
+    }
+    return sizeof(arr) / sizeof(arr[0]);
+}
+
+
+void DoProcessFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    hpaeSourceOutputNode->DoProcess();
+}
+
+void ResetFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    hpaeSourceOutputNode->Reset();
+}
+
+void ResetAllFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    hpaeSourceOutputNode->ResetAll();
+}
+
+void ConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeSourceOutputNode->Connect(preNode);
+}
+
+void ConnectWithInfoFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    HpaeNodeInfo nodeInfo;
+    hpaeSourceOutputNode->ConnectWithInfo(preNode,nodeInfo);
+}
+
+void DisConnectFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    hpaeSourceOutputNode->DisConnect(preNode);
+}
+
+void DisConnectWithInfoFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    std::shared_ptr<OutputNode<HpaePcmBuffer *>> inputs;
+    const std::shared_ptr<OutputNode<HpaePcmBuffer *>> &preNode = inputs;
+    HpaeNodeInfo nodeInfo;
+    hpaeSourceOutputNode->DisConnectWithInfo(preNode,nodeInfo);
+}
+
+void RegisterReadCallbackFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    const std::weak_ptr<ICapturerStreamCallback> &callback = std::weak_ptr<ICapturerStreamCallback>();
+    hpaeSourceOutputNode->RegisterReadCallback(callback);
+}
+
+void SetStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    HpaeSessionState captureState;
+    hpaeSourceOutputNode->SetState(captureState);
+}
+
+void GetStateFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    hpaeSourceOutputNode->GetState();
+}
+
+void SetAppUidFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    int32_t appUid = GetData<int32_t>();
+    hpaeSourceOutputNode->SetAppUid(appUid);
+}
+
+void GetAppUidFuzzTest()
+{
+    HpaeNodeInfo nodeInfo;
+    auto hpaeSourceOutputNode = std::make_shared<HpaeSourceOutputNode>(nodeInfo);
+    hpaeSourceOutputNode->GetAppUid();
+}
+
+typedef void (*TestFuncs[12])();
+
+TestFuncs g_testFuncs = {
+    DoProcessFuzzTest,
+    ResetFuzzTest,
+    ResetAllFuzzTest,
+    ConnectFuzzTest,
+    ConnectWithInfoFuzzTest,
+    DisConnectFuzzTest,
+    DisConnectWithInfoFuzzTest,
+    RegisterReadCallbackFuzzTest,
+    SetStateFuzzTest,
+    GetStateFuzzTest,
+    SetAppUidFuzzTest,
+    GetAppUidFuzzTest,
+};
+
+bool FuzzTest(const uint8_t* rawData, size_t size)
+{
+    if (rawData == nullptr) {
+        return false;
+    }
+
+    // initialize data
+    RAW_DATA = rawData;
+    g_dataSize = size;
+    g_pos = 0;
+
+    uint32_t code = GetData<uint32_t>();
+    uint32_t len = GetArrLength(g_testFuncs);
+    if (len > 0) {
+        g_testFuncs[code % len]();
+    } else {
+        AUDIO_INFO_LOG("%{public}s: The len length is equal to 0", __func__);
+    }
+
+    return true;
+}
+
+} // namespace AudioStandard
+} // namesapce OHOS
+
+/* Fuzzer entry point */
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t* data, size_t size)
+{
+    if (size < OHOS::AudioStandard::THRESHOLD) {
+        return 0;
+    }
+
+    OHOS::AudioStandard::FuzzTest(data, size);
+    return 0;
+}
diff --git a/test/fuzztest/hpaesourceoutputnode_fuzzer/project.xml b/test/fuzztest/hpaesourceoutputnode_fuzzer/project.xml
new file mode 100644
index 0000000000000000000000000000000000000000..7133b2b92440904a5ed04b838733acea0f97486a
--- /dev/null
+++ b/test/fuzztest/hpaesourceoutputnode_fuzzer/project.xml
@@ -0,0 +1,25 @@
+<?xml version="1.0" encoding="utf-8"?>
+<!-- Copyright (c) 2024 Huawei Device Co., Ltd.
+
+     Licensed under the Apache License, Version 2.0 (the "License");
+     you may not use this file except in compliance with the License.
+     You may obtain a copy of the License at
+
+          http://www.apache.org/licenses/LICENSE-2.0
+
+     Unless required by applicable law or agreed to in writing, software
+     distributed under the License is distributed on an "AS IS" BASIS,
+     WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+     See the License for the specific language governing permissions and
+     limitations under the License.
+-->
+<fuzz_config>
+  <fuzztest>
+    <!-- maximum length of a test input -->
+    <max_len>1000</max_len>
+    <!-- maximum total time in seconds to run the fuzzer -->
+    <max_total_time>300</max_total_time>
+    <!-- memory usage limit in Mb -->
+    <rss_limit_mb>4096</rss_limit_mb>
+  </fuzztest>
+</fuzz_config>
